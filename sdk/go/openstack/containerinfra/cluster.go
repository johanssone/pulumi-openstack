// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package containerinfra

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Import
//
// Clusters can be imported using the `id`, e.g.
//
// ```sh
//  $ pulumi import openstack:containerinfra/cluster:Cluster cluster_1 ce0f9463-dd25-474b-9fe8-94de63e5e42b
// ```
type Cluster struct {
	pulumi.CustomResourceState

	ApiAddress        pulumi.StringOutput      `pulumi:"apiAddress"`
	ClusterTemplateId pulumi.StringOutput      `pulumi:"clusterTemplateId"`
	CoeVersion        pulumi.StringOutput      `pulumi:"coeVersion"`
	ContainerVersion  pulumi.StringOutput      `pulumi:"containerVersion"`
	CreateTimeout     pulumi.IntOutput         `pulumi:"createTimeout"`
	CreatedAt         pulumi.StringOutput      `pulumi:"createdAt"`
	DiscoveryUrl      pulumi.StringOutput      `pulumi:"discoveryUrl"`
	DockerVolumeSize  pulumi.IntOutput         `pulumi:"dockerVolumeSize"`
	FixedNetwork      pulumi.StringOutput      `pulumi:"fixedNetwork"`
	FixedSubnet       pulumi.StringOutput      `pulumi:"fixedSubnet"`
	Flavor            pulumi.StringOutput      `pulumi:"flavor"`
	FloatingIpEnabled pulumi.BoolOutput        `pulumi:"floatingIpEnabled"`
	Keypair           pulumi.StringOutput      `pulumi:"keypair"`
	Kubeconfig        pulumi.StringMapOutput   `pulumi:"kubeconfig"`
	Labels            pulumi.MapOutput         `pulumi:"labels"`
	MasterAddresses   pulumi.StringArrayOutput `pulumi:"masterAddresses"`
	MasterCount       pulumi.IntOutput         `pulumi:"masterCount"`
	MasterFlavor      pulumi.StringOutput      `pulumi:"masterFlavor"`
	MergeLabels       pulumi.BoolPtrOutput     `pulumi:"mergeLabels"`
	Name              pulumi.StringOutput      `pulumi:"name"`
	NodeAddresses     pulumi.StringArrayOutput `pulumi:"nodeAddresses"`
	NodeCount         pulumi.IntOutput         `pulumi:"nodeCount"`
	ProjectId         pulumi.StringOutput      `pulumi:"projectId"`
	Region            pulumi.StringOutput      `pulumi:"region"`
	StackId           pulumi.StringOutput      `pulumi:"stackId"`
	UpdatedAt         pulumi.StringOutput      `pulumi:"updatedAt"`
	UserId            pulumi.StringOutput      `pulumi:"userId"`
}

// NewCluster registers a new resource with the given unique name, arguments, and options.
func NewCluster(ctx *pulumi.Context,
	name string, args *ClusterArgs, opts ...pulumi.ResourceOption) (*Cluster, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ClusterTemplateId == nil {
		return nil, errors.New("invalid value for required argument 'ClusterTemplateId'")
	}
	var resource Cluster
	err := ctx.RegisterResource("openstack:containerinfra/cluster:Cluster", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetCluster gets an existing Cluster resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetCluster(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ClusterState, opts ...pulumi.ResourceOption) (*Cluster, error) {
	var resource Cluster
	err := ctx.ReadResource("openstack:containerinfra/cluster:Cluster", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Cluster resources.
type clusterState struct {
	ApiAddress        *string                `pulumi:"apiAddress"`
	ClusterTemplateId *string                `pulumi:"clusterTemplateId"`
	CoeVersion        *string                `pulumi:"coeVersion"`
	ContainerVersion  *string                `pulumi:"containerVersion"`
	CreateTimeout     *int                   `pulumi:"createTimeout"`
	CreatedAt         *string                `pulumi:"createdAt"`
	DiscoveryUrl      *string                `pulumi:"discoveryUrl"`
	DockerVolumeSize  *int                   `pulumi:"dockerVolumeSize"`
	FixedNetwork      *string                `pulumi:"fixedNetwork"`
	FixedSubnet       *string                `pulumi:"fixedSubnet"`
	Flavor            *string                `pulumi:"flavor"`
	FloatingIpEnabled *bool                  `pulumi:"floatingIpEnabled"`
	Keypair           *string                `pulumi:"keypair"`
	Kubeconfig        map[string]string      `pulumi:"kubeconfig"`
	Labels            map[string]interface{} `pulumi:"labels"`
	MasterAddresses   []string               `pulumi:"masterAddresses"`
	MasterCount       *int                   `pulumi:"masterCount"`
	MasterFlavor      *string                `pulumi:"masterFlavor"`
	MergeLabels       *bool                  `pulumi:"mergeLabels"`
	Name              *string                `pulumi:"name"`
	NodeAddresses     []string               `pulumi:"nodeAddresses"`
	NodeCount         *int                   `pulumi:"nodeCount"`
	ProjectId         *string                `pulumi:"projectId"`
	Region            *string                `pulumi:"region"`
	StackId           *string                `pulumi:"stackId"`
	UpdatedAt         *string                `pulumi:"updatedAt"`
	UserId            *string                `pulumi:"userId"`
}

type ClusterState struct {
	ApiAddress        pulumi.StringPtrInput
	ClusterTemplateId pulumi.StringPtrInput
	CoeVersion        pulumi.StringPtrInput
	ContainerVersion  pulumi.StringPtrInput
	CreateTimeout     pulumi.IntPtrInput
	CreatedAt         pulumi.StringPtrInput
	DiscoveryUrl      pulumi.StringPtrInput
	DockerVolumeSize  pulumi.IntPtrInput
	FixedNetwork      pulumi.StringPtrInput
	FixedSubnet       pulumi.StringPtrInput
	Flavor            pulumi.StringPtrInput
	FloatingIpEnabled pulumi.BoolPtrInput
	Keypair           pulumi.StringPtrInput
	Kubeconfig        pulumi.StringMapInput
	Labels            pulumi.MapInput
	MasterAddresses   pulumi.StringArrayInput
	MasterCount       pulumi.IntPtrInput
	MasterFlavor      pulumi.StringPtrInput
	MergeLabels       pulumi.BoolPtrInput
	Name              pulumi.StringPtrInput
	NodeAddresses     pulumi.StringArrayInput
	NodeCount         pulumi.IntPtrInput
	ProjectId         pulumi.StringPtrInput
	Region            pulumi.StringPtrInput
	StackId           pulumi.StringPtrInput
	UpdatedAt         pulumi.StringPtrInput
	UserId            pulumi.StringPtrInput
}

func (ClusterState) ElementType() reflect.Type {
	return reflect.TypeOf((*clusterState)(nil)).Elem()
}

type clusterArgs struct {
	ClusterTemplateId string                 `pulumi:"clusterTemplateId"`
	CreateTimeout     *int                   `pulumi:"createTimeout"`
	DiscoveryUrl      *string                `pulumi:"discoveryUrl"`
	DockerVolumeSize  *int                   `pulumi:"dockerVolumeSize"`
	FixedNetwork      *string                `pulumi:"fixedNetwork"`
	FixedSubnet       *string                `pulumi:"fixedSubnet"`
	Flavor            *string                `pulumi:"flavor"`
	FloatingIpEnabled *bool                  `pulumi:"floatingIpEnabled"`
	Keypair           *string                `pulumi:"keypair"`
	Labels            map[string]interface{} `pulumi:"labels"`
	MasterCount       *int                   `pulumi:"masterCount"`
	MasterFlavor      *string                `pulumi:"masterFlavor"`
	MergeLabels       *bool                  `pulumi:"mergeLabels"`
	Name              *string                `pulumi:"name"`
	NodeCount         *int                   `pulumi:"nodeCount"`
	Region            *string                `pulumi:"region"`
}

// The set of arguments for constructing a Cluster resource.
type ClusterArgs struct {
	ClusterTemplateId pulumi.StringInput
	CreateTimeout     pulumi.IntPtrInput
	DiscoveryUrl      pulumi.StringPtrInput
	DockerVolumeSize  pulumi.IntPtrInput
	FixedNetwork      pulumi.StringPtrInput
	FixedSubnet       pulumi.StringPtrInput
	Flavor            pulumi.StringPtrInput
	FloatingIpEnabled pulumi.BoolPtrInput
	Keypair           pulumi.StringPtrInput
	Labels            pulumi.MapInput
	MasterCount       pulumi.IntPtrInput
	MasterFlavor      pulumi.StringPtrInput
	MergeLabels       pulumi.BoolPtrInput
	Name              pulumi.StringPtrInput
	NodeCount         pulumi.IntPtrInput
	Region            pulumi.StringPtrInput
}

func (ClusterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*clusterArgs)(nil)).Elem()
}

type ClusterInput interface {
	pulumi.Input

	ToClusterOutput() ClusterOutput
	ToClusterOutputWithContext(ctx context.Context) ClusterOutput
}

func (*Cluster) ElementType() reflect.Type {
	return reflect.TypeOf((*Cluster)(nil))
}

func (i *Cluster) ToClusterOutput() ClusterOutput {
	return i.ToClusterOutputWithContext(context.Background())
}

func (i *Cluster) ToClusterOutputWithContext(ctx context.Context) ClusterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterOutput)
}

func (i *Cluster) ToClusterPtrOutput() ClusterPtrOutput {
	return i.ToClusterPtrOutputWithContext(context.Background())
}

func (i *Cluster) ToClusterPtrOutputWithContext(ctx context.Context) ClusterPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterPtrOutput)
}

type ClusterPtrInput interface {
	pulumi.Input

	ToClusterPtrOutput() ClusterPtrOutput
	ToClusterPtrOutputWithContext(ctx context.Context) ClusterPtrOutput
}

type clusterPtrType ClusterArgs

func (*clusterPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Cluster)(nil))
}

func (i *clusterPtrType) ToClusterPtrOutput() ClusterPtrOutput {
	return i.ToClusterPtrOutputWithContext(context.Background())
}

func (i *clusterPtrType) ToClusterPtrOutputWithContext(ctx context.Context) ClusterPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterPtrOutput)
}

// ClusterArrayInput is an input type that accepts ClusterArray and ClusterArrayOutput values.
// You can construct a concrete instance of `ClusterArrayInput` via:
//
//          ClusterArray{ ClusterArgs{...} }
type ClusterArrayInput interface {
	pulumi.Input

	ToClusterArrayOutput() ClusterArrayOutput
	ToClusterArrayOutputWithContext(context.Context) ClusterArrayOutput
}

type ClusterArray []ClusterInput

func (ClusterArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Cluster)(nil)).Elem()
}

func (i ClusterArray) ToClusterArrayOutput() ClusterArrayOutput {
	return i.ToClusterArrayOutputWithContext(context.Background())
}

func (i ClusterArray) ToClusterArrayOutputWithContext(ctx context.Context) ClusterArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterArrayOutput)
}

// ClusterMapInput is an input type that accepts ClusterMap and ClusterMapOutput values.
// You can construct a concrete instance of `ClusterMapInput` via:
//
//          ClusterMap{ "key": ClusterArgs{...} }
type ClusterMapInput interface {
	pulumi.Input

	ToClusterMapOutput() ClusterMapOutput
	ToClusterMapOutputWithContext(context.Context) ClusterMapOutput
}

type ClusterMap map[string]ClusterInput

func (ClusterMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Cluster)(nil)).Elem()
}

func (i ClusterMap) ToClusterMapOutput() ClusterMapOutput {
	return i.ToClusterMapOutputWithContext(context.Background())
}

func (i ClusterMap) ToClusterMapOutputWithContext(ctx context.Context) ClusterMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMapOutput)
}

type ClusterOutput struct{ *pulumi.OutputState }

func (ClusterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Cluster)(nil))
}

func (o ClusterOutput) ToClusterOutput() ClusterOutput {
	return o
}

func (o ClusterOutput) ToClusterOutputWithContext(ctx context.Context) ClusterOutput {
	return o
}

func (o ClusterOutput) ToClusterPtrOutput() ClusterPtrOutput {
	return o.ToClusterPtrOutputWithContext(context.Background())
}

func (o ClusterOutput) ToClusterPtrOutputWithContext(ctx context.Context) ClusterPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Cluster) *Cluster {
		return &v
	}).(ClusterPtrOutput)
}

type ClusterPtrOutput struct{ *pulumi.OutputState }

func (ClusterPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Cluster)(nil))
}

func (o ClusterPtrOutput) ToClusterPtrOutput() ClusterPtrOutput {
	return o
}

func (o ClusterPtrOutput) ToClusterPtrOutputWithContext(ctx context.Context) ClusterPtrOutput {
	return o
}

func (o ClusterPtrOutput) Elem() ClusterOutput {
	return o.ApplyT(func(v *Cluster) Cluster {
		if v != nil {
			return *v
		}
		var ret Cluster
		return ret
	}).(ClusterOutput)
}

type ClusterArrayOutput struct{ *pulumi.OutputState }

func (ClusterArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Cluster)(nil))
}

func (o ClusterArrayOutput) ToClusterArrayOutput() ClusterArrayOutput {
	return o
}

func (o ClusterArrayOutput) ToClusterArrayOutputWithContext(ctx context.Context) ClusterArrayOutput {
	return o
}

func (o ClusterArrayOutput) Index(i pulumi.IntInput) ClusterOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Cluster {
		return vs[0].([]Cluster)[vs[1].(int)]
	}).(ClusterOutput)
}

type ClusterMapOutput struct{ *pulumi.OutputState }

func (ClusterMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]Cluster)(nil))
}

func (o ClusterMapOutput) ToClusterMapOutput() ClusterMapOutput {
	return o
}

func (o ClusterMapOutput) ToClusterMapOutputWithContext(ctx context.Context) ClusterMapOutput {
	return o
}

func (o ClusterMapOutput) MapIndex(k pulumi.StringInput) ClusterOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) Cluster {
		return vs[0].(map[string]Cluster)[vs[1].(string)]
	}).(ClusterOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterInput)(nil)).Elem(), &Cluster{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterPtrInput)(nil)).Elem(), &Cluster{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterArrayInput)(nil)).Elem(), ClusterArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterMapInput)(nil)).Elem(), ClusterMap{})
	pulumi.RegisterOutputType(ClusterOutput{})
	pulumi.RegisterOutputType(ClusterPtrOutput{})
	pulumi.RegisterOutputType(ClusterArrayOutput{})
	pulumi.RegisterOutputType(ClusterMapOutput{})
}
